# Формальний опис алгоритму: 
### Топологічне сортування орієнтованих, ациклічних графів.

# Чітка постановка задачі:
### Впорядковування вершин безконтурного орієнтованого графу згідно з частковим порядком, визначеним ребрами цього графу на множині його вершин. <a href="(https://uk.wikipedia.org/wiki/Топологічне_сортування)">source</a>

# Вхідні та вихідні дані для алгоритму:

Вхідні дані: Граф у вигляді списку вершин та списку ребер(ациклічний, орієнтований)
Вихідні дані: Послідовність вершин графа, яка відображає правильний порядок обробки.

# Опис алгоритму Кана псевдокодом:

Перевірка наявності циклів у графі.
Якщо граф має цикли, повідомлення про неможливість топологічного сортування.
Інакше:
  Створення списку вершин без вхідних ребер.
  Поки є вершини без вхідних ребер:
  Вибрати вершину без вхідних ребер.
  Додати її до результату.
  Видалити обрану вершину та всі її ребра з графа.
Перевірка, чи залишилися ребра у графі. Якщо так, повідомлення про неможливість топологічного сортування.
Теоретичні оцінки складності:

## Часова складність: O(V + E), де V - кількість вершин, E - кількість ребер.
## Простірна складність: O(V + E).

### Для зберігання графа були обрані наступні структури даних:
### Список вершин (nodes) - множина set().
### Список ребер (edges) - список списків.
### Матриця суміжності (adjacency_matrix) - список списків.
### Список суміжності (adjacency_list) - словник.
### Використано бібліотеку NetworkX для деяких внутрішніх перевірок і для візуалізації графа.
### Головна функція topological_sort використовує алгоритм пошуку в ширину для знаходження топологічного сортування.
### Для перевірки графу на утворення циклів використовується DFS (is_cyclic_with_edge - метод в нашому коді) і для тестів ми використовували ще бібліотеку networkX для перевірок наших алгоритмів.
