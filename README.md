# Алгоритму: 
### Топологічне сортування орієнтованих, ациклічних графів алгоритмом Кана.

# Постановка задачі:
### Впорядковування вершин безконтурного орієнтованого графу згідно з частковим порядком, визначеним ребрами цього графу на множині його вершин. 
[https://uk.wikipedia.org/wiki/Топологічне_сортування](#source)

# Вхідні та вихідні дані для алгоритму:

### Вхідні дані: 
Граф у вигляді списку вершин та списку ребер(ациклічний, орієнтований)
### Вихідні дані: 
Послідовність вершин графа, яка відображає правильний порядок обробки.

# Опис алгоритму Кана псевдокодом:

Створення списку вершин без вхідних ребер.(шукаємо origin вершини)
  Поки є вершини без вхідних ребер:
    Вибрати вершину без вхідних ребер.
    Додати її до результату.
    Видалити обрану вершину та всі її ребра з графа.
Перевірка, чи залишлись ребра в графі, якщо так => помилка, у графі є цикл
Інше:
  повернути  топологічно відортований список.
  
# Теоретичні оцінки складності:

## Часова складність: O(V + E), де V - кількість вершин, E - кількість ребер.
## Простірна складність: O(V + E).

# Короткі коментарі по реалізації коду:

## Для зберігання графа були обрані наступні структури даних:
### Список вершин (nodes) - множина set().
### Список ребер (edges) - список списків.
### Матриця суміжності (adjacency_matrix) - список списків.
### Список суміжності (adjacency_list) - словник.
## Інтсрументи і методі:
### Використано бібліотеку NetworkX для деяких внутрішніх перевірок(для дебагу наших алгоритмів перевірки на ациклічність і т.д.) і для візуалізації графа.
### Були реалізовані різні види представлення графів(список суміжності, матриця суміжностей)
### topological_sort: вибираємо вершину(orgin - в яку не входять ребра, але можуть виходити) потім додаємо цю вершину до списку, який ми будемо повертати як топологічно відсортований, далі видаляємо вершину цю(та ребра, що з неї виходять) і знову дивимось першу, яка трапиться на шляху вершина origin, якщо у нас є цикл в методі, то ми не зможемо відосортувати, бо дійдемо до того, що не можливо буде визначити вершину origin(бо на то воно і є цикл(замкнутий ланцюг)), тому цей алгоритм працює тільки з ациклічними вершинами.
### Для перевірки графу на утворення циклів використовується DFS (is_cyclic_with_edge - метод в нашому коді) і для тестів ми використовували ще бібліотеку networkX для перевірок наших алгоритмів.
